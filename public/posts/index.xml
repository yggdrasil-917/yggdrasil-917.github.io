<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on Tempest Engine Dev</title>
		<link>http://localhost:1313/posts/</link>
		<description>Recent content in Posts on Tempest Engine Dev</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>en-us</language>
		<lastBuildDate>Thu, 27 Jun 2024 07:28:57 -0700</lastBuildDate>
		<atom:link href="http://localhost:1313/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>Serialization</title>
			<link>http://localhost:1313/posts/serialization/serialization/</link>
			<pubDate>Thu, 27 Jun 2024 07:28:57 -0700</pubDate>
			
			<guid>http://localhost:1313/posts/serialization/serialization/</guid>
			<description><![CDATA[%!s(<nil>)]]></description>
			<content type="html"><![CDATA[<h1 id="table-of-contents">Table of Contents</h1>
<ul>
<li><a href="#pupping">Pupping</a></li>
<li><a href="#text-file-pupping">Text Pupping</a></li>
<li><a href="#binary-file-pupping">Binary Pupping</a></li>
<li><a href="#random-thoughts">Random Thoughts</a></li>
</ul>
<h2 id="pupping">Pupping</h2>
<p>The method used for serialization in Tempest is referred to as pupping or pup which stands for pack-unpack. I first heard about this method close to a decade ago but the idea of it stuck with me. That idea is fairly simple. Rather than creating serilization and deserialization functions for each object type we instead create pupper objects for each type of medium bundled with a set of read and write functions for each fundamental data type. A pupper object will contain all the data and functions needed to handle both reading and writing for a specific medium like file or network serialization. Take for example, a text file pupper object might contain a file stream that each pup function would use to read and write with it.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// Base class snippet for every pupper object
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Pupper</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">enum</span> <span class="k">class</span> <span class="nc">IoMode</span> <span class="o">:</span> <span class="n">uint8</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Read</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="n">Write</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">WriteKey</span><span class="p">(</span><span class="k">const</span> <span class="n">String</span><span class="o">&amp;</span> <span class="cm">/*newKey*/</span><span class="p">,</span> <span class="kt">bool</span> <span class="cm">/*addNewLine */</span><span class="o">=</span> <span class="nb">false</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">PupPrimitive</span><span class="p">(</span><span class="kt">char</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">PupPrimitive</span><span class="p">(</span><span class="n">String</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">PupPrimitive</span><span class="p">(</span><span class="n">uint8</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">PupPrimitive</span><span class="p">(</span><span class="n">uint16</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">PupPrimitive</span><span class="p">(</span><span class="n">uint32</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">PupPrimitive</span><span class="p">(</span><span class="n">uint64</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">PupPrimitive</span><span class="p">(</span><span class="n">int8</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">PupPrimitive</span><span class="p">(</span><span class="n">int16</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">PupPrimitive</span><span class="p">(</span><span class="n">int32</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">PupPrimitive</span><span class="p">(</span><span class="n">int64</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">PupPrimitive</span><span class="p">(</span><span class="n">half</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">PupPrimitive</span><span class="p">(</span><span class="kt">float</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">PupPrimitive</span><span class="p">(</span><span class="kt">double</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">PupPrimitive</span><span class="p">(</span><span class="kt">bool</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Any extra functions...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="k">protected</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">IoMode</span> <span class="n">mode</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h2 id="text-file-pupping">Text File Pupping</h2>
<p>It is always a good idea to support text based serialization. In Tempest, the text file pupper implements the Pupper base class posted above. There are some missing functions in that snippet but are crucial functions for text file serialization. One of the biggest advantages of using text based serialization is that it is human readable and so it is also very easy to edit and version control. In the editor most things will use this text file pupper object. In the game, game settings are stored in text but everything else is stored in binary.</p>
<p>During the development of the format the text pupper uses I realized I was using a very verbose schema for the text serialization. It was kinda a simpler XML style and this was not really an ideal outcome in my opinion. In the end the schema was redone to look similar to what YAML does. This lead to the serialized text being easier to read and edit. Plus it was also easier to parse so it got a little faster after the reimplementation. The schema YAML uses is essentially a key value pair where the value can be a simple POD(plain old data type) or it could be an array. This is the same for the text file pupper does. Arrays and string value types need to serialize a little bit more data, namely the length of the array or string.</p>
<p>The text file pupper essentially boils down to using a file stream for reading and writing. When deserializing, the pupper loads all the text file&rsquo;s content into RAM so as to avoid reading from disk every time it reads a variables data. This means it operates on a binary blob buffer when reading data and this leads to optimal performance. For serialization it just uses the file stream object directly every time it writes data for a variable instead of writing to a binary blob in memory.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// Same functions get used for both serialization and deserialization
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Pupper</span><span class="o">*</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">uint32</span> <span class="n">version</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">p</span><span class="o">-&gt;</span><span class="n">WriteKey</span><span class="p">(</span><span class="s">&#34;Version&#34;</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="n">PupPrimitive</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">version</span><span class="p">);</span>
</span></span></code></pre></div><h2 id="binary-file-pupping">Binary File Pupping</h2>
<p>The binary file pupper object works exactly the same as the text file pupper. The only difference is that the pup functions for reading and writing are working with binary data instead of text. This is the pupper of choice for serializing assets and several other things in the engine. This allows serialization to take less disk space and generally makes it fast to load at runtime.</p>
<h2 id="random-thoughts">Random Thoughts</h2>
<p>When serializing structs, it&rsquo;s important to also serialize data that can identify the version of that struct. This allows for versioning the data of a struct that gets serialized. For example, if a member variable is removed from serialization you will want to know if you are loading serialized data that still has that removed variable. With a simple version number on the struct being serialized you can have a more robust serialization system. In the example given, after removing the variable from serialization you would also increment the version number for that struct. Then during deserialization you can compare the serialized version number against what the latest struct version number is and then make decisions according to those differences. In Tempest 4 bytes are used to represent the version number of a struct, a uint32. This is likely a bit too much for most cases where maybe 2 or even 1 byte might be enough to represent all possible versions of a certain struct before launching a game.</p>
<p>Also worth mentioning is that new kinds of pupper objects can be created that are not simply writing to a local file. For instance, if you need a network serializer then this is possible to do using this framework. The same kinds of read and write functions can be overwritten to write to memory buffer and at a later point just sent over the network. I&rsquo;m sure there are plenty of other use cases where this pupping framework can be applied to great success and the best part about it is that it is very simple to implement and maintain.</p>
]]></content>
		</item>
		
		<item>
			<title>Asset System</title>
			<link>http://localhost:1313/posts/asset-system/asset-system/</link>
			<pubDate>Wed, 26 Jun 2024 08:40:45 -0700</pubDate>
			
			<guid>http://localhost:1313/posts/asset-system/asset-system/</guid>
			<description><![CDATA[%!s(<nil>)]]></description>
			<content type="html"><![CDATA[<h1 id="table-of-contents">Table of Contents</h1>
<ul>
<li><a href="#assets">Assets</a></li>
<li><a href="#asset-lifetime">AssetLifetime</a></li>
<li><a href="#asset-registry">AssetRegistry</a></li>
<li><a href="#cooking">Cooking</a></li>
<li><a href="#cook-on-the-fly">CookOnTheFly</a></li>
<li><a href="#offline-cooking">OfflineCooking</a></li>
</ul>
<h2 id="assets">Assets</h2>
<p>The Tempest engine, like most other engines out there, has a concept of an asset along with an asset manager that can handle asset lifetimes as well as asset cooking. The engine contains a base class that all asset types derive from. A simplified version of that Asset base class is below.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">AssetHandle</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// This contains the unique path to the asset, stored as a string 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// and a hash value of that path evaluated at compile time using constexpr.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">StringHash</span> <span class="n">id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="k">operator</span> <span class="nf">uint64</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">id</span><span class="p">.</span><span class="n">GetHash</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">operator</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">id</span><span class="p">.</span><span class="n">ToString</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">operator</span> <span class="n">fs</span><span class="o">::</span><span class="n">path</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">id</span><span class="p">.</span><span class="n">ToString</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">operator</span> <span class="nf">uint64</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">id</span><span class="p">.</span><span class="n">GetHash</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">operator</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">id</span><span class="p">.</span><span class="n">ToString</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Asset</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">protected</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">AssetHandle</span> <span class="n">handle</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint64</span> <span class="n">typeId</span><span class="p">;</span> <span class="c1">// Hashed value based on the type of asset
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// some more things
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  
</span></span><span class="line"><span class="cl">  <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// helper functions
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">const</span> <span class="n">AssetHandle</span><span class="o">&amp;</span> <span class="n">GetHandle</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">handle</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint64</span> <span class="nf">AssetId</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">handle</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">AssetPath</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">handle</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>Let&rsquo;s talk a little bit about the AssetHandle struct. This is the entryway to loading assets in the Tempest engine. They are essentially a wrapper aroung a hashed string with some helper methods for ease of use with certain APIs. Asset handles support serialization so when they get deserialized we can tell the asset manager to load the asset represented by the asset handle. This allows game scripts to save asset references so for example, a game script could have an asset handle that points to a particle system asset. When the script gets initialized it will also tell the asset manager to load the asset represented by the handle. It is important to note that the asset manager will not load the same asset twice but instead checks an internal cache for loaded assets and returns early if it has been loaded before otherwise the asset is loaded and the cache is updated. There is a slight caveat to that behavior that will be explained later when talking about asset lifetimes.</p>
<p>By default assets get loaded synchronously but there is support for async loading. The reason async loading is not the default is due to certain asset types lacking threading support. The engine was upgraded to c++20 recently which gives us access to coroutines so that could be a possible extension to synchronous asset loading in the future that might be worth exploring. Something worth mentioning is that all engine specific source assets are stored in plain text as this makes it very easy to edit outside of the editor and makes diffing with your version control software of choice very easy. They are however stored in binary form after they are cooked.</p>
<p>Based on a recommendation found in the Game Engine Architecture book by Gregory, the string hash function used is FNV-1a. It&rsquo;s a pretty simple algorithm to implement with a really low collision rate so it should be rare the times a different string produces the same hash value as another string. That said it is still a good idea to have debug code check for collisions in the editor. If there are collisions the solution is just to rename the string that produced the collision.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// Sample FNV-1a implementation
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define FNV_OFFSET 2166136261u
</span></span></span><span class="line"><span class="cl"><span class="cp">#define FNV_PRIME 16777619u
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="n">size_t</span> <span class="nf">CalculateFNV</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">constexpr</span> <span class="n">size_t</span> <span class="n">prime</span> <span class="o">=</span> <span class="n">FNV_PRIME</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">size_t</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">FNV_OFFSET</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">str</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">hash</span> <span class="o">=</span> <span class="p">(</span><span class="n">hash</span> <span class="o">^</span> <span class="p">(</span><span class="o">*</span><span class="n">str</span><span class="p">))</span> <span class="o">*</span> <span class="n">prime</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">++</span><span class="n">str</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">(</span><span class="n">hash</span> <span class="o">^</span> <span class="p">(</span><span class="o">*</span><span class="n">str</span><span class="p">))</span> <span class="o">*</span> <span class="n">prime</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="asset-lifetime">Asset Lifetime</h2>
<p>The Tempest engine doesn&rsquo;t have a garbage collection system like what you would find in Unreal Engine. Due to the design of the game being made with this engine, it is very clear what asset lifetimes will be so a complex garbage collection system is not needed. The design pretty much ties the asset lifetime to the lifetime of a level. With that knowledge we can assume that when a level is unloaded it is safe to delete any and all assets loaded for that level. For the sake of simplicity in the design of this asset lifetime management system, the engine does not try to be smart and check what sort of assets the level we are transitioning to has so that the engine may skip loading assets it has already loaded into memory. In practice this means we reload an asset that was already loaded in the previous level but it hasn&rsquo;t been a source of performance issues as level transitions are still very fast. This is something that may need to be considered in the future if level complexity gets high enough that load times suffer because of this.</p>
<p>So how does the asset manager keep loaded assets internally? Well it keeps a nested UnorderedMap similar to the one below. An UnorderedMap is the same as std::unordered_map but using custom allocators.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">using</span> <span class="n">AssetPtr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Asset</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">UnorderedMap</span><span class="o">&lt;</span><span class="n">uint64</span><span class="p">,</span> <span class="n">UnorderedMap</span><span class="o">&lt;</span><span class="n">uint64</span><span class="p">,</span> <span class="n">AssetPtr</span><span class="o">&gt;&gt;</span> <span class="n">loadedAssets</span><span class="p">;</span>
</span></span></code></pre></div><p>Each level loaded into memory keeps a map of the assets loaded for that specific level. The outer map uses a key of type uint64 that represents the hash of a level and the value is the map of loaded assets for that level. The inner map uses a uint64 type for a key as well which is the asset&rsquo;s hashed id and the values are unique pointers to the asset. Using smart pointers for the assets lets of release all the memory used by those assets once we clear the map, typically done during a level transition. This way of managing assets does lead to the potential of duplicating assets in memory if multiple levels load the same asset but so far in practice it hasn&rsquo;t been a source of concern.</p>
<p>This lifetime system has a couple of &ldquo;special&rdquo; kinds of levels that are useful for some unique purposes. One such level is referred to as the permanent scene id. This is useful for loading global assets, in other words, assets the game may need at any time while the game is running or if you want to preload certain common assets. Such assets are things like UI textures and fonts. It is much better to load these when the game starts instead of reloading the assets any time a UI menu is invoked. These global assets then get released when game exits so from a asset lifetime perspective, these assets are always safe to invoke while the game is running. Another special level type is for transient assets. These are assets that need to be loaded for a temporary task and you want to free the memory afterwards.</p>
<p>It is important to note that the asset manager returns a struct called AssetRef instead of a pointer to the asset being loaded. Then when the actual asset is needed that asset ref object can be used to get a temporary pointer to the asset. If the pointer is not null then we have a valid asset and can do whatever we need. The asset ref struct is simply two uint64 member variables. One for the level&rsquo;s hash that owns the asset and the other is the asset hash itself. The main reason for using this kind of indirection is so that the asset manager can internally do modifications to the asset without invaliding pointers to it. For example, hot reloading an asset will create a new asset pointer so the previous one becomes a dangling pointer but this is not a problem with the current level of indirection.</p>
<h2 id="asset-registry">Asset Registry</h2>
<p>The asset registry is essentially one large map of cooked assets that is created and managed by the editor and the cooker. The map stores asset metadata that can be useful for editor features like moving a file to another location within the content system. Whenever an asset is cooked, metadata associated with that asset gets added to the registry and later serialized. In the beginning this registry had more uses outside of the editor but they have been slowly phased out as they&rsquo;ve seen little use and instead is more an editor only feature these days. The metadata can include things like GUIDs, file paths, and other useful bits of info. The registry itself is stored in plain text for development purposes but can also be stored in binary form.</p>
<h2 id="cooking">Cooking</h2>
<p>Like a lot of other engines, Tempest engine will ingest different kinds of assets authored through DCC tools and convert them to a custom engine specific binary format. The engine takes an approach similar to what Unity does when it imports an asset. Tempest has more or less a custom vtable for all the import functions required to support every type of asset in the engine. So part of the process in supporting a specific type of asset is to map an asset extension to an import function. So for example, a jpeg asset will invoke the importer function for a texture asset. When the import is done the cooked asset is stored in a folder for cooked assets for a given platform. However, the source asset is left unmodified in the content folder making it easy to do updates to the source asset. If no valid asset extension to import function is found then the asset is ignored and it is logged that it was skipped. It&rsquo;s also worth pointing out that some types of assets also create a metafile alongside the source asset similar to what Unity does. As of now only texture assets do this in order to store texture settings in that metafile.</p>
<p>Cooking is only allowed to happen in the editor or when the offline cooker is running. The player is only allowed to read cooked data and will error out if it tries to cook an asset it does not have the data for. There are technically two cooking modes, cook on the fly and offline cooking. Both will be expanded on later in this article.</p>
<h2 id="cook-on-the-fly">Cook on the fly</h2>
<p>This is the mode the editor uses and what this means is that it will only cook an asset when a request to load that asset occurs. When loading an asset, the asset manager checks to see if there is a cooked version of that source asset. If there isn&rsquo;t then it proceeds to import the asset otherwise, it will check if the source asset has been updated since the last time it was cooked. If it has been updated since then it will get cooked. This is where the std::filesystem API comes in handy to check the last modification timestamp of both the source asset file and the cooked binary file. So if the last modification timestamp for the source asset file is newer then we know we should cook it. After cooking is done the asset registry is updated to include the new asset.</p>
<h2 id="offline-cooking">Offline Cooking</h2>
<p>The offline cooker is what the build pipeline uses to cook the assets. The cooker takes as input a list of levels to include in the build. It can also accept a list of assets to always cook regardless of whether or not they are referenced in a level. This is to accommodate the case where assets are loaded from scripts instead of being in the level&rsquo;s file. By default the offline cooker will use incremental cooking where it operates much like the cook on the fly method so only dirty assets get updated. It can also do a full recook of all the assets to make sure everything is up to date and this is the preferred method when running the build pipeline. How this tool figures out what to cook is fairly simple. Generally speaking, the assets are stored in text format and are only in binary after being cooked. Level assets follow this pattern. Any time the level has a reference to an asset it will have serialized data for an asset handle in text. So the tool opens a file handle to the level&rsquo;s text file and scans for those tokens. By the end it will have a list of all referenced assets in that level. It does the same for all levels that will be included in the build so it ends up with all statically referenced assets. The tool then adds the assets that should always be included in the build and finally we can start the actual cooking process. Once the cooking is done there is some diagnostic data reported at the end where things like number of assets cooked is reported, total disk memory used by the assets, total disk space used by asset type, etc.</p>
]]></content>
		</item>
		
		<item>
			<title>Tempest Engine</title>
			<link>http://localhost:1313/posts/tempest-engine/tempest-engine/</link>
			<pubDate>Sun, 23 Jun 2024 06:40:54 -0700</pubDate>
			
			<guid>http://localhost:1313/posts/tempest-engine/tempest-engine/</guid>
			<description><![CDATA[%!s(<nil>)]]></description>
			<content type="html"><![CDATA[<h1 id="table-of-contents">Table of Contents</h1>
<ol>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#why-build-a-new-engine">Why Build A New Engine</a></li>
<li><a href="#pros">Pros</a></li>
<li><a href="#cons">Cons</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ol>
<h2 id="introduction">Introduction</h2>
<p>About two years ago I had started building a new engine in C++ with the initial intention of having some base framework I could experiment with and also challenging myself to build a proper game editor since I had yet to do that. I had built a few engines in the past but it was always with the intention of learning more things so I generally avoided using third party libraries. This meant I would implement everything myself or at least the vast majority of it. For this engine though, it was more about making things with it so I was ok with using third party libraries. After a year into the development of the engine, I had a suite of tools that were good enough to convince me to use them to make a game and thus fulfill my intent of creating something with this engine. At that point what I call the Tempest Engine was sort of born. Since then I&rsquo;ve been working on the engine whenever the game needed a feature I had not implemented yet.</p>
<p>To get a little bit ahead of myself, I added a screenshot below of what the editor currently looks like while running one of the combat scenarios in the game. I&rsquo;ll eventually go over the various things about the engine in different posts. I should also mention all the art assets are placeholder at this point.</p>
<p><img src="/images/tempest-engine/editor.png" alt="Editor Screenshot" title="Tempest Editor"></p>
<h2 id="why-build-a-new-engine">Why Build A New Engine</h2>
<p>Some of you may ask why use an unproven engine for my game instead of using an off the shelf solution like Unity or Unreal that has been around for a long time. I have many reasons why I&rsquo;m not going down that route even though I&rsquo;m familiar with both of those engines. I would say that&rsquo;s also why I don&rsquo;t want to use them for anything other than work these days. I had mainly been using Unity for the last few years and right now is just not a great time to use that engine. Too many packages are in development hell or have been prematurely marked as production ready when they really aren&rsquo;t. That codebase is in a lot of flux right now. Solutions that worked for a certain package version become obsolete very quickly while the problems still linger so a brand new solution needs to figured out.</p>
<p>As for Unreal, it has all I need but I also don&rsquo;t care for how bloated it is these days. Editor can be fairly unstable depending on what you&rsquo;re doing. Running Unreal makes my PC work so hard it almost sounds like I&rsquo;m launching a rocket to space with how fast the fans are spinning. I also have never really liked blueprints or how Epic has pushed that workflow on most things in the engine. C++ in Unreal feels worse than it should be and I say that while understanding some of the limitations c++ bring to the scripting side of game development. Namely hot reloading c++ code is a nightmare and will not always work. It might not ever feel as well integrated as c# in Unity. Maybe c++ modules can help change some of that but that&rsquo;s never gonna happen in Unreal without a full rewrite.</p>
<p>There&rsquo;s also something that&rsquo;s been on my mind since I started this and that&rsquo;s the fact that I wouldn&rsquo;t have to pay Epic or Unity money to use my own engine. I may have to pay some amount for some of the libraries I&rsquo;m using, assuming the game makes enough money that I need to pay them. Considering platforms like Steam take a 30% cut, console platforms do the same, and other things that take away from your total I think every bit you can save helps out in the end.</p>
<p>Bottom line is that I could make my game in either engine but I feel I would be fighting against engine issues due to how they were made or design principles where things have to be done a very specific way that engine forces you to adopt. I&rsquo;m confident in my abilities to make Tempest good enough to release a game on it some day. That said I&rsquo;ll first talk about some of the pros of building my own engine and then I&rsquo;ll mention some of the cons.</p>
<h2 id="pros">Pros</h2>
<p>Lets start with the obvious pro. I&rsquo;ve implemented everything myself. This means I have intimate knowledge on how all the systems in the engine work. There is no blackbox so to speak. Whenever bugs happen I tend to have a good idea of what the problem is and what the solution should be. This results in bugs being fixed in a much quicker pace than if I was using Unity or Unreal.</p>
<p>Another pro is that I have a pretty good idea of what I want my game to be so the requirements are well defined. Because of that I don&rsquo;t have to rely on a highly generic game engine with loads of features I will never need or use and possibly even deal with problems some of those features may cause during development. Having a good idea of what the game will be also leads to a lean codebase. I keep track of how large the codebase is just for comparing against other engines out there. Without considering third party libraries the engine and game codebase totals around 150K lines of code at the time of this writing. Compare that to the millions of lines of code engines like Unreal and Unity have just for the engine alone.</p>
<p>A lean codebase has several advantages. Keeping it small keeps the learning curve manageable, making it easier to bring other developers on board. Build times are considerably faster than, for example, building Unreal from source so we can make engine modifications without having to wait an excessive amount of time compiling and linking. This also means I don&rsquo;t need to have a beast of a computer to have fast compile times. I currently develop on an almost 5 year old laptop and iteration times are still fast. With that laptop, it would be horrible to compile Unreal from source.</p>
<p>Custom pipeline for everything. You decide how the content is cooked for your game, how the builds get made, shader compilation, etc. I can&rsquo;t stress enough how great it is to be able to make a new build and only have to wait seconds for it to finish. These days engines are taking a very long time to make even the simplest of builds. Take Unity, for example, where using URP and making a build of a simple scene takes a very long time.</p>
<p>There&rsquo;s plenty of other pros but I&rsquo;ll leave it at that and move on to some of the cons.</p>
<h2 id="cons">Cons</h2>
<p>Custom codebase means it is less mature than long standing engines. There will be problems other engines have already solved. The codebase will likely be lacking in features that others may be accustomed to. Things like editor workflows, keyboard shortcuts, etc. It is up to me to spend time on what is valuable as far as extending the engine feature set.</p>
<p>Currently the engine does not make it trivial to add new shaders. Adding a new shader will usually require adding new c++ code as well. This is in part by design at the moment as I tend to have fewer shaders that rely on dynamic branching for slightly different behaviors instead of doing what most developers do and make a new shader variant for a feature.</p>
<h2 id="conclusion">Conclusion</h2>
<p>All in all I&rsquo;m pretty happy with what the engine is capable of and where it&rsquo;s going. At this point it has many of the features I would expect out of an off the shelf engine and I&rsquo;m confident they will mature over time. There&rsquo;s lots of room for improvement and I&rsquo;ll definitely be talking more about the engine in later posts.</p>
]]></content>
		</item>
		
	</channel>
</rss>
