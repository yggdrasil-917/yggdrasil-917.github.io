<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>Posts on Tempest Engine Dev</title>
		<link>https://yggdrasil-917.github.io/posts/</link>
		<description>Recent content in Posts on Tempest Engine Dev</description>
		<generator>Hugo -- gohugo.io</generator>
		<language>en-us</language>
		<lastBuildDate>Wed, 03 Jul 2024 11:57:54 -0700</lastBuildDate>
		<atom:link href="https://yggdrasil-917.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
		
		<item>
			<title>Scripting With Cpp</title>
			<link>https://yggdrasil-917.github.io/posts/scripting-with-cpp/scripting-with-cpp/</link>
			<pubDate>Wed, 03 Jul 2024 11:57:54 -0700</pubDate>
			
			<guid>https://yggdrasil-917.github.io/posts/scripting-with-cpp/scripting-with-cpp/</guid>
			<description><![CDATA[%!s(<nil>)]]></description>
			<content type="html"><![CDATA[<p>Early on in Tempest&rsquo;s development it was decided not to adopt a scripting language and instead use c++, the same language used to make the engine. This more or less goes against the norm these days seeing as how most engines have a scripting language. In fact, you can probably count the number of professional engines that only offer c++ for scripting in one hand. Unreal Engine being by far the most popular one in that category. There are some smaller engines like <a href="https://flaxengine.com/">Flax</a> that offers c++ or c# for scripting otherwise, you&rsquo;re likely using something other than c++ for your scripting needs.</p>
<p>I&rsquo;ve been asked several times in the past what scripting language I decided to adopt for Tempest and people are usually surprised at the fact that I stuck with c++. So I&rsquo;ll use this post to go over the reasons why, however, I can&rsquo;t stress enough that all decisions have pros and cons. This is no different. That said I can live with the cons for the kinds of games I&rsquo;m trying to make with Tempest.</p>
<h2 id="deciding-on-cpp">Deciding On Cpp</h2>
<p>So how did I go about deciding on c++? There&rsquo;s actually a lot of things I did before making my decision and I&rsquo;ll cover some of them here. The very first thing I did was to take a look at the current state of the game scripting language landscape. The engine I made before Tempest was a long time ago and for that I had decided to use Lua as the scripting language. One of the main reasons was to get first hand knowledge on setting up a scripting language in a custom engine and at the time Lua seemed pretty popular for this. Fast forward to present time and the scripting language ecosystem hasn&rsquo;t really changed all that much since the last time I looked into this. The popular scripting languages still seemed to be the same as they were back then. Mostly c#, lua, and python. I&rsquo;m ignoring languages like GDScript as that is tied to Godot but I do recognize that one has gained a lot of popularity as Godot has gotten more popular. That said I&rsquo;ve added below a few thoughts I had when evaluating each of those languages.</p>
<ul>
<li><strong>c#</strong> - Unity made this super popular for game scripting and there is a large community out there with loads of third party libraries for anything you may need. Unity however, has done many custom things to make c# useful for game development. Things that would not be available to my custom engine and thus makes it a tougher sell to adopt c#. I was close to deciding to bite the bullet and add support for it in Tempest but looking at Mono quickly removed any desire to use it so I didn&rsquo;t.</li>
<li><strong>lua</strong> - Another very popular option touted to be lightweight and easy to integrate. I can definitely vouch for it being easy to integrate into a custom c++ engine. It is dynamically typed though and that is something I&rsquo;m not really willing to deal with unless work makes me. Dynamic typing makes it so easy to hide bugs that I just prefer not rely too much on systems like that. The community has gotten bigger but it still seems to lag behind the other two languages I&rsquo;m mentioning here. This also means there are less libraries to be found than in c# or python so it&rsquo;s possible you may have to do more things yourself.</li>
<li><strong>python</strong> - Similar enough to lua but again dynamically typed so I want to stay away from it. Has a lot of libraries and large community. Performance though is a serious issue as it is very easy to write code that looks performant but due to how the language works it ends up being a hard to detect performance bottleneck. Some of that will be mitigated with experience using the language but it is still a tough sell.</li>
</ul>
<p>Another thing I don&rsquo;t see mentioned often with regards to scripting languages is debugging your scripts in your favorite IDE. In many cases, you may need to write a custom plugin to enable breakpoints inside your chosen scripting language and that&rsquo;s if it is even possible to do that. I know it is fairly new but Unreal Verse does not support breakpoints right now and instead expects developers to use print statements for their debugging. For some of the bigger game engine developers, it&rsquo;s common for them to provide their own IDE plugins to enable things like breakpoints for example. This is sort of a hidden cost to adopting a scripting language whereas, sticking with c++ you already have all of that in working condition.</p>
<p>Memory management is another key thing to consider. A lot of scripting languages may have garbage collection or rely on ARC whereas, c/c++ works very differently by default but can be extended to have things like GC (see Unreal Engine). In the case of c#, you have to think about managed memory and if you have to cross the boundary between managed and unmanaged then things can start getting a bit annoying to deal with the requirements that can have. Not to mention crossing language boundaries can be annoying as well. I&rsquo;m picking a little on c# here but crossing language boundaries can be defficult in other scripting languages.</p>
<p>Developing and maintaining a powerful scripting API for your game dev needs is a ton of work. It&rsquo;s not uncommon to duplicate work already done in native. For instance, a math library built to meet your game development needs is likely going to be required in your scripting API but you likely already have that built in your native language or are using a third party library for that. All of a sudden you need support for vectors, matrices, RNG, and the list goes on and on. You might think that it&rsquo;s a good idea to just build a wrapper API in your scripting language that simply calls native functions all the time but you will learn it isn&rsquo;t a good idea as crossing language barriers has non-negligible cost that quickly adds up to become a performance issue. This then brings up the age old question of what exactly should be exposed at an API level to the scripting language. It&rsquo;s not always clear how to handle this and is something that should be asked anytime more things are added to your scripting layer. This becomes a bigger problem as a solo developer since extending the scripting layer also means a larger codebase to maintain. This is also a problem that much larger engines run into as well. I&rsquo;ve run into so many situations using Unreal where certain functions don&rsquo;t exists in blueprint but are there in c++ or a variant of a function I need is in blueprint but not the correct variant. If you&rsquo;re working from source then it is likely easy to add support for it but otherwise you&rsquo;re stuck with that limitation and creates tons of frustrations.</p>
<p>Now lets talk about performance for a bit. This is one major sticking point with scripting languages in general. The argument being that scripting languages exist for their ease of use and not for their performance. On the one hand, I&rsquo;m glad the simplicity of these scripting languages has made it possible for more people to contribute to gameplay, editor tools, etc. On the other hand, I&rsquo;ve had one too many situations throughout my career where I had to convert scripts into c++ in order to improve performance and be able to ship features. While this isn&rsquo;t the norm, it does happen often enough that sometimes it makes me question the usefulness of scripting languages. This also applies to node based scripting tools like blueprint. The nodes can often be a little too high level to the point where developers don&rsquo;t even think about what a node may actually be doing behind the scenes and just assume it is a fast operation. Oh and if the node graph is complex enough that the original author can&rsquo;t even debug it when problems occur then you can bet that&rsquo;s going to be redone in c++.</p>
<p>One huge thing I do miss about using c++ for scripting has to do with hot reloading. C++ has always been difficult on that front. Tons of solutions developed over the years but none of them seem to be very reliable or even working these days. Even the live coding feature in Unreal is very finicky. There are many situations where hot reloading can&rsquo;t work in the language. For most part you&rsquo;re only able to change data values and only in your cpp files as header changes are out of the question. This is something scripting languages usually excel at. I say usually since for several years now hot reloading c# code in Unity has been inconsistent to say the least. The main issue they&rsquo;ve had for a while now is that reloading their c# domain can take a very long time and sometimes after it has finished you may run into issues with your scripts. Point being that just adopting a scripting language doesn&rsquo;t automatically make hot reloading easy or useful. I&rsquo;m secretly hoping that c++ modules might be able to make things better but so far I haven&rsquo;t seen much work done on that front so it remains to be seen if this might be the way forward for hot reloading c++ code. It&rsquo;s also worth mentioning that VS 2022 brought a hot reloading feature to c++ and I was delighted that it worked once upon a time but as my project has gotten much bigger that feature stopped working.</p>
<p>I haven&rsquo;t talked about compilation yet. C++ is obviously a compiled language and as such will also generate machine code that in theory is also optimal for the platform it is running on. This does mean that it needs to be compiled and linked before it can be used whereas some scripting languages are interpreted so no compilation or linking is needed. This  means faster iteration times which in game development is very important. C++ can be slow to compile if you&rsquo;re careless with how you structure the codebase. This is something you need to be on top of throughout development so you don&rsquo;t fall into the trap of including all sorts of headers everywhere in your codebase and then realize your compile times are horrible because of that. This is pretty much what happend to Unreal Engine 4 early on before somebody had the unfortunate task of cleaning up header includes througout the engine and coming up with better coding practices to minimize that issue moving forward.</p>
<p>I&rsquo;ve rambled on a bit too long and I haven&rsquo;t mentioned all the things I considered but hopefully this gets the point across as to how I went about deciding on c++ for everything in my engine. This post will maybe come across as a bit harsh on scripting languages but I do see their benefit in the industry despite my opinions. However, I&rsquo;m not trying to make a competitor to any of the popular game engines out there so I feel no need to emulate every single thing they do and instead I&rsquo;d rather do my own thing. At the end of the day that&rsquo;s sort of the point of making a custom game engine isn&rsquo;t it?</p>
]]></content>
		</item>
		
		<item>
			<title>Crash Reporting</title>
			<link>https://yggdrasil-917.github.io/posts/crash-reporting/crash-reporting/</link>
			<pubDate>Sun, 30 Jun 2024 10:21:04 -0700</pubDate>
			
			<guid>https://yggdrasil-917.github.io/posts/crash-reporting/crash-reporting/</guid>
			<description><![CDATA[%!s(<nil>)]]></description>
			<content type="html"><![CDATA[<ul>
<li><a href="#supporting-minidumps">Supporting Minidumps</a></li>
<li><a href="#crash-report">Crash Report</a></li>
<li><a href="#win32-ui">Win32 UI</a></li>
<li><a href="#trigger-crash-reporter">Trigger Crash Reporter</a></li>
<li><a href="#where-reports-live">Where Reports Live</a></li>
</ul>
<p>If you&rsquo;ve ever had to debug a fatal exception then you likely know how hard it can be to fix those issues when you only have the steps to reproduce the problem and sometimes you don&rsquo;t even have that. These days a lot of things can contribute to a crash and it&rsquo;s important to get as much information as you can. Hardware information is always very useful to have. Things like cpu and gpu models, how much RAM the system has, etc. Gathering hardware information can sometimes shed a light on problems specific to a piece of hardware or driver version. It would be great if there was an automated way to collect this information, among other things, and store it somewhere developers can look at the data to do some debugging on their end.</p>
<p>This is pretty much what all popular engines do. Unity and Unreal for example, have a separate application to handle crash reporting on their editors as well as any games made with those engines. The engine will make sure to launch their crash reporter whenever a fatal exception has occured. This application is very straightforward to use and it&rsquo;s responsibilties boil down to automatically bundling a minidump, most recent log file, and other data so that it can send it off to a server. The crash reporter also lets the user type some additional information to attach to the report. Things like what user was doing when the crash occured and anything else they may want to add. This is the approach the Tempest crash reporter takes. A screenshot below shows what the Tempest crash reporter looks like in all its Win32 glory. Looks sort of ugly but gets the job done.</p>
<p><img src="/images/crash-reporting/CrashReporter.png" alt="Crash Reporter"></p>
<h2 id="supporting-minidumps">Supporting Minidumps</h2>
<p>If you aren&rsquo;t aware what application minidumps are then I will briefly mention what they are. In short, the minidump is a file that contains various useful information for debugging at a later point in time. Information such as call stack at the time of the fatal exception, local variables, loaded modules, and will also point to the source code line that triggered the exception. Needless to say, this is going to be the most important file to have from a crash report. However, these files do not get created automatically and the c++ project needs to be configured properly for them to be useful. Using Visual Studio 2022 as the IDE of choice, what you need to configure is in your C/C++ general section, set <strong>Debug Information Format</strong> to <strong>Program Database</strong> and then make sure that in your linker debugging section&rsquo;s <strong>Generate Debug Info</strong> is set to <strong>Generate Debug Information</strong>. This should make your release or shipping builds generate debug symbols in a PDB file. It is also good practice to save these PDB files when you make a new build so you can easily use the correct PDB file when loading up the minidump in VS or your debugger of choice.</p>
<p>The next thing required is to create the minidump file when the fatal exception is being handled. There are many articles out there that describe how to do this. It isn&rsquo;t a lot of code so I&rsquo;ll post below what Tempest does so you can see for yourself.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// After this runs a minidump file is created at the location
</span></span></span><span class="line"><span class="cl"><span class="c1">// specified by the filepath variable.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">CreateMinidump</span><span class="p">(</span><span class="k">struct</span> <span class="nc">_EXCEPTION_POINTERS</span><span class="o">*</span> <span class="n">apExceptionInfo</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">HMODULE</span> <span class="n">mhLib</span> <span class="o">=</span> <span class="o">::</span><span class="n">LoadLibrary</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">&#34;dbghelp.dll&#34;</span><span class="p">));</span>
</span></span><span class="line"><span class="cl">  <span class="n">MINIDUMPWRITEDUMP</span> <span class="n">pDump</span> <span class="o">=</span> <span class="p">(</span><span class="n">MINIDUMPWRITEDUMP</span><span class="p">)</span><span class="o">::</span><span class="n">GetProcAddress</span><span class="p">(</span><span class="n">mhLib</span><span class="p">,</span> <span class="s">&#34;MiniDumpWriteDump&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">filepath</span><span class="p">[</span><span class="n">MAX_PATH</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="n">snprintf</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">filepath</span><span class="p">),</span> <span class="s">&#34;%s/crashdump.dmp&#34;</span><span class="p">,</span> <span class="n">Application</span><span class="o">::</span><span class="n">GetAppDataDir</span><span class="p">());</span> 
</span></span><span class="line"><span class="cl">  <span class="n">HANDLE</span> <span class="n">hFile</span> <span class="o">=</span> <span class="o">::</span><span class="n">CreateFileA</span><span class="p">(</span><span class="n">filepath</span><span class="p">,</span> <span class="n">GENERIC_WRITE</span><span class="p">,</span> <span class="n">FILE_SHARE_WRITE</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">CREATE_ALWAYS</span><span class="p">,</span> <span class="n">FILE_ATTRIBUTE_NORMAL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="n">_MINIDUMP_EXCEPTION_INFORMATION</span> <span class="n">ExInfo</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">ExInfo</span><span class="p">.</span><span class="n">ThreadId</span> <span class="o">=</span> <span class="o">::</span><span class="n">GetCurrentThreadId</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="n">ExInfo</span><span class="p">.</span><span class="n">ExceptionPointers</span> <span class="o">=</span> <span class="n">apExceptionInfo</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">ExInfo</span><span class="p">.</span><span class="n">ClientPointers</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="n">pDump</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="n">GetCurrentProcessId</span><span class="p">(),</span> <span class="n">hFile</span><span class="p">,</span> <span class="n">MiniDumpNormal</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ExInfo</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="o">::</span><span class="n">CloseHandle</span><span class="p">(</span><span class="n">hFile</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>It is important to mention that the minidump file will be created by the application that just had a fatal exception. This fatal exception could be anything, including memory corruption. Due to the unknown nature of the fatal exception it is very important to be careful with the code you run when handling the exception. Particularly take care to not do any or very few dynamic memory allocations as there is no guarantee that will work. Of course, this does not only apply to creating the minidump file but anything done while handling the exception.</p>
<h2 id="crash-report">Crash Report</h2>
<p>In addition to creating a minidump file, the Tempest crash reporter will also create an additional text file that contains some useful information. It logs the exception code by value and also a string so it is easy to identify. A callstack is created but it&rsquo;s only useful in development as otherwise, in shipping builds the callstack won&rsquo;t be able to symbolicate the function addresses. It also adds some system info like what Windows OS, processor, etc. Once again, it gathers all this extra information with little dynamic memory allocations and where there are allocations, that&rsquo;s usually because the Windows API is doing some behind the scene. You can see a bit of the crash report information in the crash reporter screenshot above.</p>
<p>The last couple things the crash report generates that are also very important have to do with a unique ID for the report itself that is tied to the machine that created the crash and the other is the game&rsquo;s build number. The crash report ID is super useful as you can use external tools to bundle crash reports based on that ID so you can get a sense of what problems might be plaguing a certain user. You can also use it to track progress on improving stability for that user and set of hardware. The game build/version number is also important to track in my opinion. You can again use external software to bundle crash reports based on what version of the game and get a sense of what the major problems are for that build. I&rsquo;ll mention soon enough what software I&rsquo;m using to be able to perform these queries.</p>
<h2 id="win32-ui">Win32 UI</h2>
<p>Using the Win32 API to make the UI for the crash reporter was for the most part easy but there was one unexpected thing that was way more annoying to handle than I thought it would be. You&rsquo;ll notice in the crash reporter screenshot that there is a text box where the user can type any additional information into it. I wanted this box to handle all the main keyboard shortcut that people expect these days to work. Copy and paste keyboard shortcuts for instance, are supported by default in the Win32 API so no issues there but if you wanted to highlight all the text using Ctrl+a then you would find out that does nothing. Adding support for that was not as trivial as you might think and searching online yielded several workarounds that were more complex than I thought it needed to be. Eventually I stumbled on a post that ran into the same issue and it presented the solution they used. It was a simple solution and was easy to integrate into my crash reporter. All you have to do is create a new window procedure that specifically handles the Ctrl+a keyboard shortcut and then make the text box window use that function.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// This function will handle the Ctrl+a keyboard shortcut to highlight all the text
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">LRESULT</span> <span class="n">CALLBACK</span> <span class="nf">Edit_Prc</span><span class="p">(</span><span class="n">HWND</span> <span class="n">hwnd</span><span class="p">,</span> <span class="n">UINT</span> <span class="n">msg</span><span class="p">,</span> <span class="n">WPARAM</span> <span class="n">wParam</span><span class="p">,</span> <span class="n">LPARAM</span> <span class="n">lParam</span><span class="p">,</span> <span class="n">UINT_PTR</span> <span class="n">uIdSubclass</span><span class="p">,</span> <span class="n">DWORD_PTR</span> <span class="n">dwRefData</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">msg</span> <span class="o">==</span> <span class="n">WM_CHAR</span> <span class="o">&amp;&amp;</span> <span class="n">wParam</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">SendMessage</span><span class="p">(</span><span class="n">hwnd</span><span class="p">,</span> <span class="n">EM_SETSEL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">DefSubclassProc</span><span class="p">(</span><span class="n">hwnd</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">wParam</span><span class="p">,</span> <span class="n">lParam</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Later when creating the input text box window
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">HWND</span> <span class="n">hwnd</span> <span class="o">=</span> <span class="n">CreateWindowW</span><span class="p">(...);</span> <span class="c1">// handle to the input text box window
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">SetWindowSubclass</span><span class="p">(</span><span class="n">hwnd</span><span class="p">,</span> <span class="n">Edit_Prc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// Sets the correct window proc to handle the select all text keyboard shortcut
</span></span></span></code></pre></div><h2 id="trigger-crash-reporter">Trigger Crash Reporter</h2>
<p>Now that we&rsquo;ve talked about how the crash report data is created and what it contains, let&rsquo;s talk about how the executable prepares itself to launch the crash reporter if a fatal exception happens. In c++ this done in a very simple way. It boils down to setting up a callback that will run when a fatal exception happens. To my knowledge, on Windows there are at least two different functions that allows this setup. The Tempest engine uses <a href="https://learn.microsoft.com/en-us/windows/win32/api/errhandlingapi/nf-errhandlingapi-setunhandledexceptionfilter">SetUnhandledExceptionFilter</a> and the other option is <a href="https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/set-se-translator?view=msvc-170">_set_se_translator</a>. Whichever function the application uses the setup is the same and that&rsquo;s to call the respective function on application initialization. Deciding which function to use will highly depend on your application as well as any requirements imposed by third party libraries used so be sure to read the documentation and choose accordingly. You can easily test your setup by dereferencing an uninitialized pointer and run the executable without the debugger attached. If it is setup correctly then you should see your callback get called when the application crashes.</p>
<h2 id="where-reports-live">Where Reports Live</h2>
<p>We&rsquo;ve yet to mention what happens when the user clicks &ldquo;Send&rdquo; in the crash reporter. Obviously we need a place to store these crash reports. Some platforms may already offer a place for that and you simply need to configure your application to use it but in other cases you need to host that data yourself. Being a small developer your storage needs are going to be pretty basic and if you can save some money then all the better. This was the main thing I wanted to figure out before deciding to make the crash reporter since if there is no good and cheap solution that meets a small developer&rsquo;s needs then it might not be worth spending the time to develop it. Looking for solutions I stumbled on to a Twitter post where an indie developer mentioned using Slack as a place to send to the crash reports to. I don&rsquo;t tend to use Slack personally but I do use Discord and decided to look for a Discord specific solution. To my excitement I saw that a Discord Webhook could be used to send data to a server.</p>
<p>The steps to set this up were pretty simple. Just make a new server for the game and in that server you can make a private channel where it will host all the crash reports. Through the Discord app you can create a special webhook id for the channel that you can then use with a HTTP post request in order to send the crash report data to the channel. So the crash reporter takes care of making a zip file containing the minidump, crash report, and log file. This is set as an attachment to the HTTP post request. It also sends a string with the post request which contains the message the user typed in the crash reporter and a few other key strings that are useful for searching through the channel in Discord. These key strings are things like the user&rsquo;s unique ID and game build version number. You can use either one to filter the crash report channel using Discord&rsquo;s own search feature. So if you wanted to find all the reports attached to a specific user you can search the channel using the user&rsquo;s unique ID and see all the reports generated by that user. All super useful and for a small developer probably everything you need.</p>
]]></content>
		</item>
		
		<item>
			<title>Shader Compiler</title>
			<link>https://yggdrasil-917.github.io/posts/shader-compiler/shader-compiler/</link>
			<pubDate>Sat, 29 Jun 2024 09:27:15 -0700</pubDate>
			
			<guid>https://yggdrasil-917.github.io/posts/shader-compiler/shader-compiler/</guid>
			<description><![CDATA[%!s(<nil>)]]></description>
			<content type="html"><![CDATA[<ul>
<li><a href="#editor-integration">Editor Integration</a></li>
<li><a href="#shader-cache">Shader Cache</a></li>
<li><a href="#hot-reloading">Hot Reloading</a></li>
<li><a href="#tempest-shader">Tempest Shader</a></li>
</ul>
<p>These days every game engine out there is going to need to compile shaders but how they go about it tends to be somewhat different depending on the engine&rsquo;s needs. At the time of this writing Tempest only supports the Windows platform and supports DirectX 12 and Vulkan. The compiler uses the <a href="https://github.com/microsoft/DirectXShaderCompiler">dxc executable</a> under the hood to compile for both DX12 and Vulkan.</p>
<p>The Tempest shader compiler is a separate executable similar to what other engines do where the editor will automatically launch it as a child process. When the shader compiler is launched this way it uses inter process communication (IPC) through local sockets to send information to the editor and listen to packets from the editor. It can also run in standalone mode where it compiles all dirty shaders or optionally recompiles everything in the engine. This is the mode the build pipeline uses.</p>
<h2 id="editor-integration">Editor Integration</h2>
<p>One important thing to mention about the Tempest engine tool ecosystem is that for tools that need to communicate with other Tempest tools requires the use of IPC. This is achieved through a daemon that serves as a hub of sorts for interpreting packet types that come in and internally figures out what data to send and to what tools to send that data to. This is referred to as the Tempest Daemon. This setup is currently only used with the editor as the player does not need to talk to any other applications at the moment. On editor startup, it will configure the IPC setup by first starting up the daemon and will wait until it establishes connection with it before then starting the shader compiler. The shader compiler gets launched but not in standalone mode. It instead will be required to connect to the daemon as well before the compiler proceeds to compile any dirty shaders. Once the compiler is done an acknowledgement packet is sent to the editor if everything finished successfully otherwise, it should exit due to engine level shader errors. To finish setting up IPC, the editor spawns a new thread in order to handle all the network related IPC tasks and not block the main thread while doing so. This thread will keep running until the editor is closed.</p>
<p>Another key thing the editor will do is start a thread to handle file watching for any changes. This system is used for several things but one of them is to know when a shader file is modified while the editor is running. As soon as the thread detects a change to a shader file a network packet representing what file was changed is prepared and marshalled off to the shader compiler. The packet boils down to a string containing several tokens delimited by a semicolon. Below is the function used internally to prepare the network packet with the required information for the shader compiler to handle the compilation job. It also shows the function the shader compiler uses to send a packet to the editor when it successfully compiles a shader.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="kt">void</span> <span class="n">Packet</span><span class="o">::</span><span class="n">PrepareShaderCompilationJobPacket</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">networkAddress</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">filepath</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">shaderStage</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">entryPoint</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">defines</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">api</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">data</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">PacketType</span><span class="o">::</span><span class="n">BroadcastTo</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">payload</span><span class="p">[</span><span class="n">Packet</span><span class="o">::</span><span class="n">maxMessageSize</span><span class="p">]</span> <span class="o">=</span> <span class="p">{};</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="n">int32</span> <span class="n">charsWritten</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">defines</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">payload</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">payload</span><span class="p">),</span> <span class="s">&#34;%s;%s;%s;%s&#34;</span><span class="p">,</span> <span class="n">filepath</span><span class="p">,</span> <span class="n">api</span><span class="p">,</span> <span class="n">shaderStage</span><span class="p">,</span> <span class="n">entryPoint</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                                                  <span class="o">:</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">payload</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">payload</span><span class="p">),</span> <span class="s">&#34;%s;%s;%s;%s;%s&#34;</span><span class="p">,</span> <span class="n">filepath</span><span class="p">,</span> <span class="n">api</span><span class="p">,</span> <span class="n">shaderStage</span><span class="p">,</span> <span class="n">entryPoint</span><span class="p">,</span> <span class="n">defines</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">charsWritten</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">Warnf</span><span class="p">(</span><span class="s">&#34;Local payload buffer is too small to fit all shader compilation options&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="n">strcpy</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">broadcastPacket</span><span class="p">.</span><span class="n">ip</span><span class="p">,</span> <span class="n">networkAddress</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">strcpy</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">broadcastPacket</span><span class="p">.</span><span class="n">msg</span><span class="p">,</span> <span class="n">payload</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Used when all shader variant compilation succeeds
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">void</span> <span class="n">Packet</span><span class="o">::</span><span class="n">PrepareShaderCompilationResultPacket</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">networkAddress</span><span class="p">,</span> <span class="k">const</span> <span class="n">String</span><span class="o">&amp;</span> <span class="n">result</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">data</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">PacketType</span><span class="o">::</span><span class="n">BroadcastTo</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="kt">char</span> <span class="n">payload</span><span class="p">[</span><span class="n">Packet</span><span class="o">::</span><span class="n">maxMessageSize</span><span class="p">]{};</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="n">int32</span> <span class="n">charsWritten</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">payload</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">payload</span><span class="p">),</span> <span class="s">&#34;%s&#34;</span><span class="p">,</span> <span class="n">result</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="n">charsWritten</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="n">Warnf</span><span class="p">(</span><span class="s">&#34;Local payload buffer is too small to fit all shader compilation result&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">Debugf</span><span class="p">(</span><span class="s">&#34;CompilationResultPacket sending &#39;%s&#39; to &#39;%s&#39;&#34;</span><span class="p">,</span> <span class="n">payload</span><span class="p">,</span> <span class="n">networkAddress</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="n">strcpy</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">broadcastPacket</span><span class="p">.</span><span class="n">ip</span><span class="p">,</span> <span class="n">networkAddress</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">strcpy</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">u</span><span class="p">.</span><span class="n">broadcastPacket</span><span class="p">.</span><span class="n">msg</span><span class="p">,</span> <span class="n">payload</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="shader-cache">Shader Cache</h2>
<p>The engine has support for a shader cache that gets shipped with the executable. Only the editor and the shader compiler are able to create the shader cache. The cache itself is composed of multiple individual files instead of one large file containing all compiled shaders. This is mainly done to keep shader loading code simple but the more optimal approach is certainly to coalesce all shader caches into one large file. Each file that forms the cache is essentially binary blobs containing identifying information for all the shader variants in the blob as well as the bytecode generated from dxc for each shader variant. The shader cache&rsquo;s data is specific to the rendering backend API it belongs to so for example, there is one cache for DX12 and a different one for Vulkan.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// Sample code to pack shader variants into one binary blob after compilation succeeds
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">String</span><span class="p">,</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">BlobEntry</span><span class="o">&gt;&gt;&amp;</span> <span class="nl">it</span> <span class="p">:</span> <span class="n">g_ShaderBlobs</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">fs</span><span class="o">::</span><span class="n">path</span> <span class="n">outputPath</span> <span class="o">=</span> <span class="n">it</span><span class="p">.</span><span class="n">first</span><span class="p">;</span> 
</span></span><span class="line"><span class="cl">  <span class="n">FileHandle</span> <span class="n">handle</span> <span class="o">=</span> <span class="n">File</span><span class="o">::</span><span class="n">Open</span><span class="p">(</span><span class="n">outputPath</span><span class="p">.</span><span class="n">generic_string</span><span class="p">().</span><span class="n">c_str</span><span class="p">(),</span> <span class="n">FileMode</span><span class="o">::</span><span class="n">FM_Write</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">handle</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">Errorf</span><span class="p">(</span><span class="s">&#34;Error writing permutation shader file&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">continue</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">defer</span><span class="p">(</span><span class="n">File</span><span class="o">::</span><span class="n">Close</span><span class="p">(</span><span class="n">handle</span><span class="p">););</span>
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">signature</span> <span class="o">=</span> <span class="s">&#34;NVSP&#34;</span><span class="p">;</span> <span class="c1">// 4 byte magic number used by NVRHI
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">File</span><span class="o">::</span><span class="n">Write</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">handle</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">entries</span> <span class="o">=</span> <span class="n">g_ShaderBlobs</span><span class="p">[</span><span class="n">it</span><span class="p">.</span><span class="n">first</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">entry</span> <span class="p">:</span> <span class="n">entries</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">String</span> <span class="n">inputFilename</span> <span class="o">=</span> <span class="n">entry</span><span class="p">.</span><span class="n">compiledPermutationFile</span><span class="p">.</span><span class="n">generic_string</span><span class="p">().</span><span class="n">c_str</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">BinaryBlob</span> <span class="n">inputFileData</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">File</span><span class="o">::</span><span class="n">Load</span><span class="p">(</span><span class="n">inputFilename</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span> <span class="n">inputFileData</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="n">Errorf</span><span class="p">(</span><span class="s">&#34;Failed to open file %s&#34;</span><span class="p">,</span> <span class="n">inputFilename</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>
</span></span><span class="line"><span class="cl">      <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">ShaderBlobEntry</span> <span class="n">binaryEntry</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">binaryEntry</span><span class="p">.</span><span class="n">permutationSize</span> <span class="o">=</span> <span class="p">(</span><span class="n">uint32</span><span class="p">)</span><span class="n">entry</span><span class="p">.</span><span class="n">permutation</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">    <span class="n">binaryEntry</span><span class="p">.</span><span class="n">dataSize</span> <span class="o">=</span> <span class="n">inputFileData</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="n">File</span><span class="o">::</span><span class="n">Write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">binaryEntry</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">binaryEntry</span><span class="p">),</span> <span class="n">handle</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">File</span><span class="o">::</span><span class="n">Write</span><span class="p">(</span><span class="n">entry</span><span class="p">.</span><span class="n">permutation</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">entry</span><span class="p">.</span><span class="n">permutation</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">handle</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">File</span><span class="o">::</span><span class="n">Write</span><span class="p">(</span><span class="n">inputFileData</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">inputFileData</span><span class="p">.</span><span class="n">size</span><span class="p">,</span> <span class="n">handle</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// Function signature for loading shader from the cache
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">ShaderHandle</span> <span class="n">ShaderFactory</span><span class="o">::</span><span class="n">CreateShader</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">fileName</span>
</span></span><span class="line"><span class="cl">                                       <span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">entryName</span>
</span></span><span class="line"><span class="cl">                                       <span class="p">,</span> <span class="k">const</span> <span class="n">Vector</span><span class="o">&lt;</span><span class="n">ShaderMacro</span><span class="o">&gt;&amp;</span> <span class="n">defines</span>
</span></span><span class="line"><span class="cl">                                       <span class="p">,</span> <span class="n">nvrhi</span><span class="o">::</span><span class="n">ShaderType</span> <span class="n">shaderType</span>
</span></span><span class="line"><span class="cl">                                       <span class="p">,</span> <span class="kt">bool</span> <span class="n">forceCreate</span><span class="p">);</span>
</span></span></code></pre></div><p>As noted above with the CreateShader function, in order to create a shader we need the obvious things like filename and shader type but we also need any of the defines used to compile the shader. This is so we can get the correct shader variant from the compiled shader blob as it contains all the shader variants. For now we do a simple linear search inside that binary blob to find the correct shader permutation. It&rsquo;s simple and works well but it is definitely not a scalable solution given the problem with shader permutation explosion. If it ever does become a performance problem then a better solution is likely to add some sort of table of content built into the binary blob so searches can be done a lot quicker.</p>
<p>The game being worked on with this engine is attempting to make a variety of shaders using dynamic branching instead of the usual static branching which creates a new shader variant for each static branch. The main benefit of limiting the use of static branching is that it keeps the number of shader permutations low which in turn keeps build times very low as these days the bottleneck in a build is usually compiling all the shader permutations in the game. Downside of course, is individual shader performance can suffer but it is important to know that there are different kinds of dynamic branching with their performance impact. The shaders in Tempest tend to use dynamic branching based on a value passed to the shader from a constant buffer which means all threads take the same branch during shader execution. Branch performance has certainly gotten better over the years so people should not be afraid of using them but it goes without saying that profiling should also be done to make sure no serious issue is introduced.</p>
<h2 id="hot-reloading">Hot Reloading</h2>
<p>Every engine should make it a priority to support hot reloading of assets and shaders are no different. It makes iteration so much better and you&rsquo;ll be all the happier seeing your changes take effect quickly. In Tempest, there are two extensions for shader files. One is .hlsli for include files and the other is .hlsl which is the shader file with the entry points for whatever shader type it is. Also worth pointing that a hlsl file can have a vertex shader and a fragment shader in the same file and still compile correctly. I point this setup out because of how hot reloading is currently implemented in the engine. When the editor is running and a modification is done to a hlsl file the hot reloading logic will kick in. The editor sends a packet to the shader compiler so it takes care of compiling all the shader variants for that file. If all the shaders compiled successfully then the shader compiler will send a packet to the editor telling it that it can attempt to hot reload the shader file path contained in the packet. If even one shader variant failed to compile then the editor is never notified to hot reload the shader so things continue on unchanged until another edit is made to the shader. The compile errors are logged in the console as well as a log file for later viewing so you can see what file failed and where it failed.</p>
<p>The hot reloading logic is not executed if a hlsli file is edited. This is mainly due to not being implemented at the moment. To properly do this the shader compiler would need to store some sort of dependency graph somewhere so it can find what hlsl files depend on that modified header file and force a recompile. I also do like not having this feature as during development I mainly want to see the changes on the hlsl file I&rsquo;m actively developing instead of having any shaders dependent on that header file recompile when they aren&rsquo;t needed. There are some header changes that are too invasive that I can&rsquo;t follow this workflow and have to recompile most shaders to ensure everything is working but those are few and far between. Think for example, changing the layout or size of a constant buffer. After I&rsquo;m happy with the changes to a hlsli file I always make sure to recompile all the shaders in the engine to ensure I didn&rsquo;t miss anything. This is as simple as deleting the shader cache folder and relaunching the editor or run the shader compiler in standalone mode. Compilation is multi threaded with the game having around 1000 shaders or so last I looked so the shader compiler gets through all compilation tasks in less than 10 seconds on my laptop. That includes building the shader cache for DirectX 12 and Vulkan.</p>
<h2 id="tempest-shader">Tempest Shader</h2>
<p>Let&rsquo;s go over a simple shader example. Below is a blit shader from the Tempest engine that can support 2D texture or texture2DArray as input</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// Simple copy shader
</span></span></span><span class="line"><span class="cl"><span class="c1">// $fragment_variants TEXTURE_ARRAY
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="cp">#if TEXTURE_ARRAY
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="n">Texture2DArray</span> <span class="nl">tex</span> <span class="p">:</span> <span class="k">register</span><span class="p">(</span><span class="n">t0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#else
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="n">Texture2D</span> <span class="nl">tex</span> <span class="p">:</span> <span class="k">register</span><span class="p">(</span><span class="n">t0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="n">SamplerState</span> <span class="nl">samp</span> <span class="p">:</span> <span class="k">register</span><span class="p">(</span><span class="n">s0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">MainPS</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">in</span> <span class="n">float4</span> <span class="nl">pos</span> <span class="p">:</span> <span class="n">SV_Position</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">in</span> <span class="n">float2</span> <span class="nl">uv</span> <span class="p">:</span> <span class="n">TEXCOORD0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">out</span> <span class="n">float4</span> <span class="nl">o_rgba</span> <span class="p">:</span> <span class="n">SV_Target</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="cp">#if TEXTURE_ARRAY
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="n">uint</span> <span class="n">layer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// only need the first layer as of now
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">o_rgba</span> <span class="o">=</span> <span class="n">tex</span><span class="p">.</span><span class="n">Sample</span><span class="p">(</span><span class="n">samp</span><span class="p">,</span> <span class="n">float3</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span> <span class="n">layer</span><span class="p">));</span>
</span></span><span class="line"><span class="cl"><span class="cp">#else
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="n">o_rgba</span> <span class="o">=</span> <span class="n">tex</span><span class="p">.</span><span class="n">Sample</span><span class="p">(</span><span class="n">samp</span><span class="p">,</span> <span class="n">uv</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="p">}</span>
</span></span></code></pre></div><p>As you can see at the very top of the shader there is a comment line that starts with a $ followed by a keyword and a value. For anyone familiar with hlsl authoring in Unity, that line should make sense. For those unfamiliar with it, this line specifically tells the shader compiler that this shader file has two variants, one with TEXTURE_ARRAY defined and another one without it. You&rsquo;ll also notice that it is specifying that only the fragment shader has the variant so the other shader stages will not be affected by this shader variant. This keeps shader compilation fast and keeps memory to a minimum. At this moment the compiler supports four of these special pragma statements that I will outline below.</p>
<ul>
<li><strong>vertex_variants</strong> - Only the vertex shader produces variants specified by the list of values preceding this keyword</li>
<li><strong>fragment_variants</strong> - Only the fragment shader produces variants specified by the list of values preceding this keyword</li>
<li><strong>variants</strong> - All shader stages or compute shader will produce variants specified by the list of values preceding this keyword</li>
<li><strong>with_debug_symbols</strong> - This tells the compiler to include debug symbols for the shader file being compiled</li>
</ul>
<p>A limitation of sorts is that the entry point function for each shader stage has to have a certain name in order for the shader compiler to find. For instance, a vertex shader needs to have a MainVS as the entry point function, for fragment shader it&rsquo;s MainPS, and for a compute shader it is MainCS. This is again to keep the code simple and it has worked out fine so far so this will likely not change anytime soon. Shaders can also output to multiple render targets without any issue as long as they follow the requirements needed for MRT. There&rsquo;s a few render passes in the engine that uses that but I will cover that in a later post. For now just know that the engine uses deferred rendering so the gbuffer pass is one such pass that uses MRT for its output.</p>
<p>Another limitation of the compiler is that it does not do any reflection on the compiled shader. Due to this it is pretty common to have to write new c++ code to support a brand new shader. In a way this is intentional as it forces me to rely on existing shaders in the engine which can help keep the shader permutation problem under control. That said, at times you just have to make a new shader and live with that. I am still considering how I might implement this in the future.</p>
]]></content>
		</item>
		
		<item>
			<title>Serialization</title>
			<link>https://yggdrasil-917.github.io/posts/serialization/serialization/</link>
			<pubDate>Thu, 27 Jun 2024 07:28:57 -0700</pubDate>
			
			<guid>https://yggdrasil-917.github.io/posts/serialization/serialization/</guid>
			<description><![CDATA[%!s(<nil>)]]></description>
			<content type="html"><![CDATA[<ul>
<li><a href="#pupping">Pupping</a></li>
<li><a href="#text-file-pupping">Text Pupping</a></li>
<li><a href="#binary-file-pupping">Binary Pupping</a></li>
<li><a href="#random-thoughts">Random Thoughts</a></li>
</ul>
<h2 id="pupping">Pupping</h2>
<p>The method used for serialization in Tempest is referred to as pupping or pup which stands for pack-unpack. I first heard about this method close to a decade ago but the idea of it stuck with me. That idea is fairly simple. Rather than creating serilization and deserialization functions for each object type we instead create pupper objects for each type of medium bundled with a set of read and write functions for each fundamental data type. A pupper object will contain all the data and functions needed to handle both reading and writing for a specific medium like file or network serialization. Take for example, a text file pupper object might contain a file stream that each pup function would use to read and write with it.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// Base class snippet for every pupper object
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">class</span> <span class="nc">Pupper</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">enum</span> <span class="k">class</span> <span class="nc">IoMode</span> <span class="o">:</span> <span class="n">uint8</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">Read</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="n">Write</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">WriteKey</span><span class="p">(</span><span class="k">const</span> <span class="n">String</span><span class="o">&amp;</span> <span class="cm">/*newKey*/</span><span class="p">,</span> <span class="kt">bool</span> <span class="cm">/*addNewLine */</span><span class="o">=</span> <span class="nb">false</span><span class="p">)</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">PupPrimitive</span><span class="p">(</span><span class="kt">char</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">PupPrimitive</span><span class="p">(</span><span class="n">String</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">PupPrimitive</span><span class="p">(</span><span class="n">uint8</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">PupPrimitive</span><span class="p">(</span><span class="n">uint16</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">PupPrimitive</span><span class="p">(</span><span class="n">uint32</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">PupPrimitive</span><span class="p">(</span><span class="n">uint64</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">PupPrimitive</span><span class="p">(</span><span class="n">int8</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">PupPrimitive</span><span class="p">(</span><span class="n">int16</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">PupPrimitive</span><span class="p">(</span><span class="n">int32</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">PupPrimitive</span><span class="p">(</span><span class="n">int64</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">PupPrimitive</span><span class="p">(</span><span class="n">half</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">PupPrimitive</span><span class="p">(</span><span class="kt">float</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">PupPrimitive</span><span class="p">(</span><span class="kt">double</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">PupPrimitive</span><span class="p">(</span><span class="kt">bool</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// Any extra functions...
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="k">protected</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">IoMode</span> <span class="n">mode</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><h2 id="text-file-pupping">Text File Pupping</h2>
<p>It is always a good idea to support text based serialization. In Tempest, the text file pupper implements the Pupper base class posted above. There are some missing functions in that snippet but are crucial functions for text file serialization. One of the biggest advantages of using text based serialization is that it is human readable and so it is also very easy to edit and version control. In the editor most things will use this text file pupper object. In the game, game settings are stored in text but everything else is stored in binary.</p>
<p>During the development of the format the text pupper uses I realized I was using a very verbose schema for the text serialization. It was kinda a simpler XML style and this was not really an ideal outcome in my opinion. In the end the schema was redone to look similar to what YAML does. This lead to the serialized text being easier to read and edit. Plus it was also easier to parse so it got a little faster after the reimplementation. The schema YAML uses is essentially a key value pair where the value can be a simple POD(plain old data type) or it could be an array. This is the same for the text file pupper does. Arrays and string value types need to serialize a little bit more data, namely the length of the array or string.</p>
<p>The text file pupper essentially boils down to using a file stream for reading and writing. When deserializing, the pupper loads all the text file&rsquo;s content into RAM so as to avoid reading from disk every time it reads a variables data. This means it operates on a binary blob buffer when reading data and this leads to optimal performance. For serialization it just uses the file stream object directly every time it writes data for a variable instead of writing to a binary blob in memory.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// Same functions get used for both serialization and deserialization
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">Pupper</span><span class="o">*</span> <span class="n">p</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">uint32</span> <span class="n">version</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">p</span><span class="o">-&gt;</span><span class="n">WriteKey</span><span class="p">(</span><span class="s">&#34;Version&#34;</span><span class="p">);</span> 
</span></span><span class="line"><span class="cl"><span class="n">PupPrimitive</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">version</span><span class="p">);</span>
</span></span></code></pre></div><h2 id="binary-file-pupping">Binary File Pupping</h2>
<p>The binary file pupper object works exactly the same as the text file pupper. The only difference is that the pup functions for reading and writing are working with binary data instead of text. This is the pupper of choice for serializing assets and several other things in the engine. This allows serialization to take less disk space and generally makes it fast to load at runtime.</p>
<h2 id="random-thoughts">Random Thoughts</h2>
<p>When serializing structs, it&rsquo;s important to also serialize data that can identify the version of that struct. This allows for versioning the data of a struct that gets serialized. For example, if a member variable is removed from serialization you will want to know if you are loading serialized data that still has that removed variable. With a simple version number on the struct being serialized you can have a more robust serialization system. In the example given, after removing the variable from serialization you would also increment the version number for that struct. Then during deserialization you can compare the serialized version number against what the latest struct version number is and then make decisions according to those differences. In Tempest 4 bytes are used to represent the version number of a struct, a uint32. This is likely a bit too much for most cases where maybe 2 or even 1 byte might be enough to represent all possible versions of a certain struct before launching a game.</p>
<p>Also worth mentioning is that new kinds of pupper objects can be created that are not simply writing to a local file. For instance, if you need a network serializer then this is possible to do using this framework. The same kinds of read and write functions can be overwritten to write to memory buffer and at a later point just sent over the network. I&rsquo;m sure there are plenty of other use cases where this pupping framework can be applied to great success and the best part about it is that it is very simple to implement and maintain.</p>
]]></content>
		</item>
		
		<item>
			<title>Asset System</title>
			<link>https://yggdrasil-917.github.io/posts/asset-system/asset-system/</link>
			<pubDate>Wed, 26 Jun 2024 08:40:45 -0700</pubDate>
			
			<guid>https://yggdrasil-917.github.io/posts/asset-system/asset-system/</guid>
			<description><![CDATA[%!s(<nil>)]]></description>
			<content type="html"><![CDATA[<ul>
<li><a href="#assets">Assets</a></li>
<li><a href="#asset-lifetime">AssetLifetime</a></li>
<li><a href="#asset-registry">AssetRegistry</a></li>
<li><a href="#cooking">Cooking</a></li>
<li><a href="#cook-on-the-fly">CookOnTheFly</a></li>
<li><a href="#offline-cooking">OfflineCooking</a></li>
</ul>
<h2 id="assets">Assets</h2>
<p>The Tempest engine, like most other engines out there, has a concept of an asset along with an asset manager that can handle asset lifetimes as well as asset cooking. The engine contains a base class that all asset types derive from. A simplified version of that Asset base class is below.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">struct</span> <span class="nc">AssetHandle</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="c1">// This contains the unique path to the asset, stored as a string 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="c1">// and a hash value of that path evaluated at compile time using constexpr.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">StringHash</span> <span class="n">id</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="k">operator</span> <span class="nf">uint64</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">id</span><span class="p">.</span><span class="n">GetHash</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">operator</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">id</span><span class="p">.</span><span class="n">ToString</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">operator</span> <span class="n">fs</span><span class="o">::</span><span class="n">path</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">id</span><span class="p">.</span><span class="n">ToString</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">operator</span> <span class="nf">uint64</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">id</span><span class="p">.</span><span class="n">GetHash</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="k">operator</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">id</span><span class="p">.</span><span class="n">ToString</span><span class="p">();</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Asset</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">protected</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="n">AssetHandle</span> <span class="n">handle</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint64</span> <span class="n">typeId</span><span class="p">;</span> <span class="c1">// Hashed value based on the type of asset
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// some more things
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  
</span></span><span class="line"><span class="cl">  <span class="k">public</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// helper functions
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">const</span> <span class="n">AssetHandle</span><span class="o">&amp;</span> <span class="n">GetHandle</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">handle</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="n">uint64</span> <span class="nf">AssetId</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">handle</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">AssetPath</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">handle</span><span class="p">;</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></div><p>Let&rsquo;s talk a little bit about the AssetHandle struct. This is the entryway to loading assets in the Tempest engine. They are essentially a wrapper aroung a hashed string with some helper methods for ease of use with certain APIs. Asset handles support serialization so when they get deserialized we can tell the asset manager to load the asset represented by the asset handle. This allows game scripts to save asset references so for example, a game script could have an asset handle that points to a particle system asset. When the script gets initialized it will also tell the asset manager to load the asset represented by the handle. It is important to note that the asset manager will not load the same asset twice but instead checks an internal cache for loaded assets and returns early if it has been loaded before otherwise the asset is loaded and the cache is updated. There is a slight caveat to that behavior that will be explained later when talking about asset lifetimes.</p>
<p>By default assets get loaded synchronously but there is support for async loading. The reason async loading is not the default is due to certain asset types lacking threading support. The engine was upgraded to c++20 recently which gives us access to coroutines so that could be a possible extension to synchronous asset loading in the future that might be worth exploring. Something worth mentioning is that all engine specific source assets are stored in plain text as this makes it very easy to edit outside of the editor and makes diffing with your version control software of choice very easy. They are however stored in binary form after they are cooked.</p>
<p>Based on a recommendation found in the Game Engine Architecture book by Gregory, the string hash function used is FNV-1a. It&rsquo;s a pretty simple algorithm to implement with a really low collision rate so it should be rare the times a different string produces the same hash value as another string. That said it is still a good idea to have debug code check for collisions in the editor. If there are collisions the solution is just to rename the string that produced the collision.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="c1">// Sample FNV-1a implementation
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define FNV_OFFSET 2166136261u
</span></span></span><span class="line"><span class="cl"><span class="cp">#define FNV_PRIME 16777619u
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">constexpr</span> <span class="n">size_t</span> <span class="nf">CalculateFNV</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="k">constexpr</span> <span class="n">size_t</span> <span class="n">prime</span> <span class="o">=</span> <span class="n">FNV_PRIME</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">size_t</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">FNV_OFFSET</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">str</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">hash</span> <span class="o">=</span> <span class="p">(</span><span class="n">hash</span> <span class="o">^</span> <span class="p">(</span><span class="o">*</span><span class="n">str</span><span class="p">))</span> <span class="o">*</span> <span class="n">prime</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="o">++</span><span class="n">str</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="p">(</span><span class="n">hash</span> <span class="o">^</span> <span class="p">(</span><span class="o">*</span><span class="n">str</span><span class="p">))</span> <span class="o">*</span> <span class="n">prime</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h2 id="asset-lifetime">Asset Lifetime</h2>
<p>The Tempest engine doesn&rsquo;t have a garbage collection system like what you would find in Unreal Engine. Due to the design of the game being made with this engine, it is very clear what asset lifetimes will be so a complex garbage collection system is not needed. The design pretty much ties the asset lifetime to the lifetime of a level. With that knowledge we can assume that when a level is unloaded it is safe to delete any and all assets loaded for that level. For the sake of simplicity in the design of this asset lifetime management system, the engine does not try to be smart and check what sort of assets the level we are transitioning to has so that the engine may skip loading assets it has already loaded into memory. In practice this means we reload an asset that was already loaded in the previous level but it hasn&rsquo;t been a source of performance issues as level transitions are still very fast. This is something that may need to be considered in the future if level complexity gets high enough that load times suffer because of this.</p>
<p>So how does the asset manager keep loaded assets internally? Well it keeps a nested UnorderedMap similar to the one below. An UnorderedMap is the same as std::unordered_map but using custom allocators.</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="k">using</span> <span class="n">AssetPtr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Asset</span><span class="o">&gt;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">UnorderedMap</span><span class="o">&lt;</span><span class="n">uint64</span><span class="p">,</span> <span class="n">UnorderedMap</span><span class="o">&lt;</span><span class="n">uint64</span><span class="p">,</span> <span class="n">AssetPtr</span><span class="o">&gt;&gt;</span> <span class="n">loadedAssets</span><span class="p">;</span>
</span></span></code></pre></div><p>Each level loaded into memory keeps a map of the assets loaded for that specific level. The outer map uses a key of type uint64 that represents the hash of a level and the value is the map of loaded assets for that level. The inner map uses a uint64 type for a key as well which is the asset&rsquo;s hashed id and the values are unique pointers to the asset. Using smart pointers for the assets lets of release all the memory used by those assets once we clear the map, typically done during a level transition. This way of managing assets does lead to the potential of duplicating assets in memory if multiple levels load the same asset but so far in practice it hasn&rsquo;t been a source of concern.</p>
<p>This lifetime system has a couple of &ldquo;special&rdquo; kinds of levels that are useful for some unique purposes. One such level is referred to as the permanent scene id. This is useful for loading global assets, in other words, assets the game may need at any time while the game is running or if you want to preload certain common assets. Such assets are things like UI textures and fonts. It is much better to load these when the game starts instead of reloading the assets any time a UI menu is invoked. These global assets then get released when game exits so from a asset lifetime perspective, these assets are always safe to invoke while the game is running. Another special level type is for transient assets. These are assets that need to be loaded for a temporary task and you want to free the memory afterwards.</p>
<p>It is important to note that the asset manager returns a struct called AssetRef instead of a pointer to the asset being loaded. Then when the actual asset is needed that asset ref object can be used to get a temporary pointer to the asset. If the pointer is not null then we have a valid asset and can do whatever we need. The asset ref struct is simply two uint64 member variables. One for the level&rsquo;s hash that owns the asset and the other is the asset hash itself. The main reason for using this kind of indirection is so that the asset manager can internally do modifications to the asset without invaliding pointers to it. For example, hot reloading an asset will create a new asset pointer so the previous one becomes a dangling pointer but this is not a problem with the current level of indirection.</p>
<h2 id="asset-registry">Asset Registry</h2>
<p>The asset registry is essentially one large map of cooked assets that is created and managed by the editor and the cooker. The map stores asset metadata that can be useful for editor features like moving a file to another location within the content system. Whenever an asset is cooked, metadata associated with that asset gets added to the registry and later serialized. In the beginning this registry had more uses outside of the editor but they have been slowly phased out as they&rsquo;ve seen little use and instead is more an editor only feature these days. The metadata can include things like GUIDs, file paths, and other useful bits of info. The registry itself is stored in plain text for development purposes but can also be stored in binary form.</p>
<h2 id="cooking">Cooking</h2>
<p>Like a lot of other engines, Tempest engine will ingest different kinds of assets authored through DCC tools and convert them to a custom engine specific binary format. The engine takes an approach similar to what Unity does when it imports an asset. Tempest has more or less a custom vtable for all the import functions required to support every type of asset in the engine. So part of the process in supporting a specific type of asset is to map an asset extension to an import function. So for example, a jpeg asset will invoke the importer function for a texture asset. When the import is done the cooked asset is stored in a folder for cooked assets for a given platform. However, the source asset is left unmodified in the content folder making it easy to do updates to the source asset. If no valid asset extension to import function is found then the asset is ignored and it is logged that it was skipped. It&rsquo;s also worth pointing out that some types of assets also create a metafile alongside the source asset similar to what Unity does. As of now only texture assets do this in order to store texture settings in that metafile.</p>
<p>Cooking is only allowed to happen in the editor or when the offline cooker is running. The player is only allowed to read cooked data and will error out if it tries to cook an asset it does not have the data for. There are technically two cooking modes, cook on the fly and offline cooking. Both will be expanded on later in this article.</p>
<h2 id="cook-on-the-fly">Cook on the fly</h2>
<p>This is the mode the editor uses and what this means is that it will only cook an asset when a request to load that asset occurs. When loading an asset, the asset manager checks to see if there is a cooked version of that source asset. If there isn&rsquo;t then it proceeds to import the asset otherwise, it will check if the source asset has been updated since the last time it was cooked. If it has been updated since then it will get cooked. This is where the std::filesystem API comes in handy to check the last modification timestamp of both the source asset file and the cooked binary file. So if the last modification timestamp for the source asset file is newer then we know we should cook it. After cooking is done the asset registry is updated to include the new asset.</p>
<h2 id="offline-cooking">Offline Cooking</h2>
<p>The offline cooker is what the build pipeline uses to cook the assets. The cooker takes as input a list of levels to include in the build. It can also accept a list of assets to always cook regardless of whether or not they are referenced in a level. This is to accommodate the case where assets are loaded from scripts instead of being in the level&rsquo;s file. By default the offline cooker will use incremental cooking where it operates much like the cook on the fly method so only dirty assets get updated. It can also do a full recook of all the assets to make sure everything is up to date and this is the preferred method when running the build pipeline. How this tool figures out what to cook is fairly simple. Generally speaking, the assets are stored in text format and are only in binary after being cooked. Level assets follow this pattern. Any time the level has a reference to an asset it will have serialized data for an asset handle in text. So the tool opens a file handle to the level&rsquo;s text file and scans for those tokens. By the end it will have a list of all referenced assets in that level. It does the same for all levels that will be included in the build so it ends up with all statically referenced assets. The tool then adds the assets that should always be included in the build and finally we can start the actual cooking process. Once the cooking is done there is some diagnostic data reported at the end where things like number of assets cooked is reported, total disk memory used by the assets, total disk space used by asset type, etc.</p>
]]></content>
		</item>
		
		<item>
			<title>Tempest Engine</title>
			<link>https://yggdrasil-917.github.io/posts/tempest-engine/tempest-engine/</link>
			<pubDate>Sun, 23 Jun 2024 06:40:54 -0700</pubDate>
			
			<guid>https://yggdrasil-917.github.io/posts/tempest-engine/tempest-engine/</guid>
			<description><![CDATA[%!s(<nil>)]]></description>
			<content type="html"><![CDATA[<ol>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#why-build-a-new-engine">Why Build A New Engine</a></li>
<li><a href="#pros">Pros</a></li>
<li><a href="#cons">Cons</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ol>
<h2 id="introduction">Introduction</h2>
<p>About two years ago I had started building a new engine in C++ with the initial intention of having some base framework I could experiment with and also challenging myself to build a proper game editor since I had yet to do that. I had built a few engines in the past but it was always with the intention of learning more things so I generally avoided using third party libraries. This meant I would implement everything myself or at least the vast majority of it. For this engine though, it was more about making things with it so I was ok with using third party libraries. After a year into the development of the engine, I had a suite of tools that were good enough to convince me to use them to make a game and thus fulfill my intent of creating something with this engine. At that point what I call the Tempest Engine was sort of born. Since then I&rsquo;ve been working on the engine whenever the game needed a feature I had not implemented yet.</p>
<p>To get a little bit ahead of myself, I added a screenshot below of what the editor currently looks like while running one of the combat scenarios in the game. I&rsquo;ll eventually go over the various things about the engine in different posts. I should also mention all the art assets are placeholder at this point.</p>
<p><img src="/images/tempest-engine/editor.png" alt="Editor Screenshot" title="Tempest Editor"></p>
<h2 id="why-build-a-new-engine">Why Build A New Engine</h2>
<p>Some of you may ask why use an unproven engine for my game instead of using an off the shelf solution like Unity or Unreal that has been around for a long time. I have many reasons why I&rsquo;m not going down that route even though I&rsquo;m familiar with both of those engines. I would say that&rsquo;s also why I don&rsquo;t want to use them for anything other than work these days. I had mainly been using Unity for the last few years and right now is just not a great time to use that engine. Too many packages are in development hell or have been prematurely marked as production ready when they really aren&rsquo;t. That codebase is in a lot of flux right now. Solutions that worked for a certain package version become obsolete very quickly while the problems still linger so a brand new solution needs to figured out.</p>
<p>As for Unreal, it has all I need but I also don&rsquo;t care for how bloated it is these days. Editor can be fairly unstable depending on what you&rsquo;re doing. Running Unreal makes my PC work so hard it almost sounds like I&rsquo;m launching a rocket to space with how fast the fans are spinning. I also have never really liked blueprints or how Epic has pushed that workflow on most things in the engine. C++ in Unreal feels worse than it should be and I say that while understanding some of the limitations c++ bring to the scripting side of game development. Namely hot reloading c++ code is a nightmare and will not always work. It might not ever feel as well integrated as c# in Unity. Maybe c++ modules can help change some of that but that&rsquo;s never gonna happen in Unreal without a full rewrite.</p>
<p>There&rsquo;s also something that&rsquo;s been on my mind since I started this and that&rsquo;s the fact that I wouldn&rsquo;t have to pay Epic or Unity money to use my own engine. I may have to pay some amount for some of the libraries I&rsquo;m using, assuming the game makes enough money that I need to pay them. Considering platforms like Steam take a 30% cut, console platforms do the same, and other things that take away from your total I think every bit you can save helps out in the end.</p>
<p>Bottom line is that I could make my game in either engine but I feel I would be fighting against engine issues due to how they were made or design principles where things have to be done a very specific way that engine forces you to adopt. I&rsquo;m confident in my abilities to make Tempest good enough to release a game on it some day. That said I&rsquo;ll first talk about some of the pros of building my own engine and then I&rsquo;ll mention some of the cons.</p>
<h2 id="pros">Pros</h2>
<p>Lets start with the obvious pro. I&rsquo;ve implemented everything myself. This means I have intimate knowledge on how all the systems in the engine work. There is no blackbox so to speak. Whenever bugs happen I tend to have a good idea of what the problem is and what the solution should be. This results in bugs being fixed in a much quicker pace than if I was using Unity or Unreal.</p>
<p>Another pro is that I have a pretty good idea of what I want my game to be so the requirements are well defined. Because of that I don&rsquo;t have to rely on a highly generic game engine with loads of features I will never need or use and possibly even deal with problems some of those features may cause during development. Having a good idea of what the game will be also leads to a lean codebase. I keep track of how large the codebase is just for comparing against other engines out there. Without considering third party libraries the engine and game codebase totals around 150K lines of code at the time of this writing. Compare that to the millions of lines of code engines like Unreal and Unity have just for the engine alone.</p>
<p>A lean codebase has several advantages. Keeping it small keeps the learning curve manageable, making it easier to bring other developers on board. Build times are considerably faster than, for example, building Unreal from source so we can make engine modifications without having to wait an excessive amount of time compiling and linking. This also means I don&rsquo;t need to have a beast of a computer to have fast compile times. I currently develop on an almost 5 year old laptop and iteration times are still fast. With that laptop, it would be horrible to compile Unreal from source.</p>
<p>Custom pipeline for everything. You decide how the content is cooked for your game, how the builds get made, shader compilation, etc. I can&rsquo;t stress enough how great it is to be able to make a new build and only have to wait seconds for it to finish. These days engines are taking a very long time to make even the simplest of builds. Take Unity, for example, where using URP and making a build of a simple scene takes a very long time.</p>
<p>There&rsquo;s plenty of other pros but I&rsquo;ll leave it at that and move on to some of the cons.</p>
<h2 id="cons">Cons</h2>
<p>Custom codebase means it is less mature than long standing engines. There will be problems other engines have already solved. The codebase will likely be lacking in features that others may be accustomed to. Things like editor workflows, keyboard shortcuts, etc. It is up to me to spend time on what is valuable as far as extending the engine feature set.</p>
<p>Currently the engine does not make it trivial to add new shaders. Adding a new shader will usually require adding new c++ code as well. This is in part by design at the moment as I tend to have fewer shaders that rely on dynamic branching for slightly different behaviors instead of doing what most developers do and make a new shader variant for a feature.</p>
<h2 id="conclusion">Conclusion</h2>
<p>All in all I&rsquo;m pretty happy with what the engine is capable of and where it&rsquo;s going. At this point it has many of the features I would expect out of an off the shelf engine and I&rsquo;m confident they will mature over time. There&rsquo;s lots of room for improvement and I&rsquo;ll definitely be talking more about the engine in later posts.</p>
]]></content>
		</item>
		
	</channel>
</rss>
